{"componentChunkName":"component---src-templates-{post}-tsx-content-file-path-null","path":"/blog/2024/07-23-csr-open-graph/","result":{"data":{"markdownRemark":{"html":"<h2>개요</h2>\n<p>최근 회사에서 가볍고 빠른 성능의 사이트를 개발해야 하는 요구가 생겨 Vite와 Svelte를 사용한 SPA를 만들게 되었습니다. 이 사이트는 동적 라우팅을 통해 경로에 따라 백오피스에서 설정한 커스텀 페이지를 보여주어야 했습니다.</p>\n<p>문제는 동적 경로에 따라 OG 메타태그를 적용해야 한다는 사실이었습니다. 그동안 \"CSR = SEO가 어렵다\"라고 거의 공식처럼 알고 있었기 때문에, 처음에는 이를 해결할 방법이 없다고 생각했습니다.</p>\n<p>하지만 뜻밖에도 <a href=\"https://techblog.woowahan.com/15469/\">이 문제를 해결한 포스팅</a>을 발견하고 이를 참고하여 무사히 해결할 수 있었습니다. 비슷한 고민을 하고 있는 분들께도 해당 글이 큰 도움이 될 것입니다.</p>\n<p>이 글에서는 그 해결 과정에서 겪은 문제와 추가로 알게 된 사항들을 정리하려 합니다.</p>\n<h2>CSR에서 동적 OG 메타태그를 적용하는 방법</h2>\n<p><span\n      class=\"gatsby-resp-image-wrapper\"\n      style=\"position: relative; display: block; margin-left: auto; margin-right: auto; max-width: 545px; \"\n    >\n      <a\n    class=\"gatsby-resp-image-link\"\n    href=\"/static/662b513ecb452b1df4d7a26cca47235c/3ddad/cloudfront-events-that-trigger-lambda-functions.png\"\n    style=\"display: block\"\n    target=\"_blank\"\n    rel=\"noopener\"\n  >\n    <span\n    class=\"gatsby-resp-image-background-image\"\n    style=\"padding-bottom: 35.55555555555556%; position: relative; bottom: 0; left: 0; background-image: url('data:image/png;base64,iVBORw0KGgoAAAANSUhEUgAAABQAAAAHCAIAAACHqfpvAAAACXBIWXMAAA7DAAAOwwHHb6hkAAABgUlEQVR42jVRXUvCYBTeP+q2/9JddBV1EXQRBUU33YZBQVD0QSwvsgL70FkmqWk5E9y71Olw06kscWmuze396tXo4eHAOc95OIdzOEIInYBADw77GFOMxrW/eg+8p5bmusnHse46TCV4LJAJONaBEMSUDk21HD/+qAFJzmUKD+63Sc1S++4kszDTCh11QbT4HFK0ysubUNWLdOLnHMdxXYcl9ZYcFU9jr0dC9jBwPlsReWoUfDVjCbwPHjMv+5HswZN4dna/zkc2JKkoinlOURQAAIu2PSQ/PYIg28q3e0TLmQWB0SoneyCBamlkNdgMH45YDAaDO4EAV5SkSrnct92vUlzenNL5ReNypcnP9xN7/VK6WxAYLTlpnM59bE0b16vGxfJneC31cBMRYtz3YNDptD1EfKujh7frCmhU5XpFslWRalmi54j+xva381fa7W5TU3VFamkKszQNg6P/wAiikQMRgQj7CGPoY7MKtRwj6qrEc9i1Rx50R57r+X+/+AWxlWmomzV4EQAAAABJRU5ErkJggg=='); background-size: cover; display: block;\"\n  ></span>\n  <picture>\n          <source\n              srcset=\"/static/662b513ecb452b1df4d7a26cca47235c/59d6e/cloudfront-events-that-trigger-lambda-functions.webp 180w,\n/static/662b513ecb452b1df4d7a26cca47235c/a3012/cloudfront-events-that-trigger-lambda-functions.webp 360w,\n/static/662b513ecb452b1df4d7a26cca47235c/6305f/cloudfront-events-that-trigger-lambda-functions.webp 545w\"\n              sizes=\"(max-width: 545px) 100vw, 545px\"\n              type=\"image/webp\"\n            />\n          <source\n            srcset=\"/static/662b513ecb452b1df4d7a26cca47235c/e9ff0/cloudfront-events-that-trigger-lambda-functions.png 180w,\n/static/662b513ecb452b1df4d7a26cca47235c/f21e7/cloudfront-events-that-trigger-lambda-functions.png 360w,\n/static/662b513ecb452b1df4d7a26cca47235c/3ddad/cloudfront-events-that-trigger-lambda-functions.png 545w\"\n            sizes=\"(max-width: 545px) 100vw, 545px\"\n            type=\"image/png\"\n          />\n          <img\n            class=\"gatsby-resp-image-image\"\n            src=\"/static/662b513ecb452b1df4d7a26cca47235c/3ddad/cloudfront-events-that-trigger-lambda-functions.png\"\n            alt=\"cloudfront-events-that-trigger-lambda-functions.png\"\n            title=\"\"\n            loading=\"lazy\"\n            decoding=\"async\"\n            style=\"width:100%;height:100%;margin:0;vertical-align:middle;position:absolute;top:0;left:0;\"\n          />\n        </picture>\n  </a>\n    </span></p>\n<p>&#x3C;span style={{textAlign: 'center', margin: '0 auto', fontStyle: 'italic', color: 'var(--color-text-footer)'}}>출처: <a href=\"https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-cloudfront-trigger-events.html\">AWS 공식문서</a></span></p>\n<p>AWS CloudFront에서는 위 그림처럼 네 가지 구간에 엣지 함수를 설정할 수 있습니다.</p>\n<p>핵심 아이디어는 <strong>Viewer request</strong> 이벤트에 엣지 함수를 설정해서, 요청자가 봇인지 아닌지를 판별해 봇일 경우 <strong>OG 메타태그만을 포함한 HTML</strong>을 생성해 응답으로 보내는 것입니다.</p>\n<p>즉, 봇의 요청일 때는 Viewer request 단계에서 바로 OG 메타태그를 포함한 HTML을 반환하고, 실사용자가 요청할 때는 정상적으로 CloudFront 원본(제 경우에는 S3)을 거쳐 응답을 보냅니다.</p>\n<p>이때 주의해야 할 점은 클라이언트 사이드 라우팅이 hash 기반일 경우입니다. 해시 값은 서버로 전달되지 않으므로, 어떤 페이지를 요청하든 CloudFront는 동일한 페이지로 인식해 페이지별로 적절한 OG 태그를 적용하는 것이 불가능해집니다. 저 역시 이 문제로 인해 라우팅 라이브러리를 변경해야 했습니다.</p>\n<h2><strong>CloudFront Functions</strong> vs <strong>Lambda@Edge</strong></h2>\n<p>CloudFront Functions와 Lambda@Edge는 엣지 함수를 위한 주요 옵션이며, <a href=\"https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/edge-functions-choosing.html\">공식 문서</a>에서 좀더 상세한 내용을 확인할 수 있습니다. 제가 고려했던 주요 차이점은 다음과 같습니다.</p>\n<table>\n<thead>\n<tr>\n<th align=\"center\"></th>\n<th>CloudFront Functions</th>\n<th>Lambda@Edge</th>\n</tr>\n</thead>\n<tbody>\n<tr>\n<td align=\"center\">특징</td>\n<td>간단한 작업에 적합</td>\n<td>복잡한 작업 가능</td>\n</tr>\n<tr>\n<td align=\"center\">적용 가능한 이벤트</td>\n<td>Viewer request/response</td>\n<td>Viewer request/response,<br/>Origin request/response</td>\n</tr>\n<tr>\n<td align=\"center\">네트워크 통신</td>\n<td>X</td>\n<td>O</td>\n</tr>\n<tr>\n<td align=\"center\">외부 라이브러리 사용</td>\n<td>X</td>\n<td>O</td>\n</tr>\n<tr>\n<td align=\"center\">비용</td>\n<td>요청당 비용 청구</td>\n<td>요청 및 함수 지속 시간당<br/>비용 청구</td>\n</tr>\n</tbody>\n</table>\n<p>저의 경우, OG 태그를 동적으로 생성하기 위해 API 호출이 필요했기 때문에 Lambda@Edge를 선택할 수밖에 없었습니다.</p>\n<h2><del>람다 계층 사용</del></h2>\n<p>처음에는 Fetch API를 사용해 API 호출을 시도했지만, <code>fetch</code> 함수가 존재하지 않는다는 에러를 만났습니다. 람다 함수는 노드 환경이고 Fetch API는 웹 브라우저가 제공하는 API이기 때문입니다.</p>\n<p>저는 그 대안으로서 Aixos를 사용하고자 했습니다. Axios의 기반이 되는 XHR 역시 브라우저 API지만, Axios는 서버 사이드에서도 동작하는 라이브러리인 만큼 노드 환경에 필요한 dependency가 갖춰져 있을 거라 생각했습니다.</p>\n<p>람다 함수에서 외부 라이브러리를 사용하는 방법은 크게 두 가지였습니다.</p>\n<ul>\n<li>\n<p>외부 라이브러리를 포함하는 .zip 파일을 생성해 람다 함수에 업로드하기</p>\n</li>\n<li>\n<p><strong>람다 계층(Lambda layer)</strong> 을 이용해 외부 종속성을 추가하기</p>\n</li>\n</ul>\n<p>람다 계층은 여러 람다 함수에서 동일한 종속성을 재사용할 수 있기 때문에, 라이브러리 사용 시 권장되는 방법입니다. 저도 이 방법을 선택했고, Axios 종속성을 포함한 <code>.zip</code> 파일을 업로드해 계층을 생성했습니다.</p>\n<p>계층을 구성하는 방법은 간단한데, 우선 아래와 같은 형태로 구성되도록 .zip 파일을 만든 후 AWS 콘솔에서 람다 계층을 추가할 때 업로드하면 됩니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"text\"><pre class=\"language-text\"><code class=\"language-text\">axios-layer.zip\n└ nodejs\n  └ axios\n    └ ...</code></pre></div>\n<p><strong>람다 함수의 런타임 버전이 계층의 호환 런타임 버전에 포함되어야 한다</strong>는 점만 주의하면 계층 생성에서 크게 어려운 점은 없었습니다.</p>\n<p>저는 Axios 종속성을 위한 계층을 생성하고 이를 람다 함수에 추가했습니다. 그리고 <strong>Lambda@Edge에는 계층 사용이 불가능하다</strong>는 사실을 뒤늦게 알게 되었습니다. (<a href=\"https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-at-edge-function-restrictions.html#lambda-at-edge-restrictions-features\"></a>)</p>\n<h2>네트워크 통신, 그리고 해결</h2>\n<p>람다 계층을 사용할 수 없다는 것을 알게 된 후, <a href=\"https://nodejs.org/api/https.html\">노드의 HTTPS 모듈</a>을 사용해 API 호출을 구현했습니다. Lambda@Edge 관련 문서에는 이 내용이 명확히 나와 있지 않았지만, AWS 블로그에서 관련 내용을 찾아 적용할 수 있었습니다. (<a href=\"https://aws.amazon.com/ko/blogs/networking-and-content-delivery/leveraging-external-data-in-lambdaedge/\"></a>)</p>\n<p>HTTPS 모듈은 사용 방법이 다소 복잡해서, 아래와 같이 한번 래핑해서 사용했습니다.</p>\n<div class=\"gatsby-highlight\" data-language=\"javascript\"><pre class=\"language-javascript\"><code class=\"language-javascript\"><span class=\"token keyword\">const</span> <span class=\"token function-variable function\">fetchData</span> <span class=\"token operator\">=</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">url</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n  <span class=\"token keyword\">return</span> <span class=\"token keyword\">new</span> <span class=\"token class-name\">Promise</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">(</span><span class=\"token parameter\">resolve<span class=\"token punctuation\">,</span> reject</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n    https\n      <span class=\"token punctuation\">.</span><span class=\"token function\">get</span><span class=\"token punctuation\">(</span>url<span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">res</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">setEncoding</span><span class=\"token punctuation\">(</span><span class=\"token string\">'utf8'</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        <span class=\"token keyword\">let</span> rawData <span class=\"token operator\">=</span> <span class=\"token string\">''</span><span class=\"token punctuation\">;</span>\n\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'data'</span><span class=\"token punctuation\">,</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">chunk</span><span class=\"token punctuation\">)</span> <span class=\"token operator\">=></span> <span class=\"token punctuation\">{</span>\n          rawData <span class=\"token operator\">+=</span> chunk<span class=\"token punctuation\">.</span><span class=\"token function\">toString</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n\n        res<span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'end'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n          <span class=\"token keyword\">try</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token keyword\">const</span> parsedData <span class=\"token operator\">=</span> <span class=\"token constant\">JSON</span><span class=\"token punctuation\">.</span><span class=\"token function\">parse</span><span class=\"token punctuation\">(</span>rawData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span>parsedData<span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span> <span class=\"token keyword\">catch</span> <span class=\"token punctuation\">(</span>e<span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n            <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n          <span class=\"token punctuation\">}</span>\n        <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span>\n      <span class=\"token punctuation\">.</span><span class=\"token function\">on</span><span class=\"token punctuation\">(</span><span class=\"token string\">'error'</span><span class=\"token punctuation\">,</span> <span class=\"token keyword\">function</span> <span class=\"token punctuation\">(</span><span class=\"token parameter\">e</span><span class=\"token punctuation\">)</span> <span class=\"token punctuation\">{</span>\n        <span class=\"token function\">resolve</span><span class=\"token punctuation\">(</span><span class=\"token punctuation\">{</span> <span class=\"token literal-property property\">error</span><span class=\"token operator\">:</span> <span class=\"token boolean\">true</span> <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n      <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n  <span class=\"token punctuation\">}</span><span class=\"token punctuation\">)</span><span class=\"token punctuation\">;</span>\n<span class=\"token punctuation\">}</span><span class=\"token punctuation\">;</span></code></pre></div>\n<p>또한 함수가 제대로 동작하는지 확인하기 위해 테스트 데이터를 수집하는 과정이 필요했습니다. 다음과 같은 단계로 테스트 데이터를 구해 실제 요청을 처리할 수 있었습니다.</p>\n<ol>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-event-structure.html\">Lambda@Edge 이벤트 구조</a> 문서에서 일반적인 Viewer request 이벤트를 구해 테스트하고, 기본적인 함수를 구성합니다.</p>\n</li>\n<li>\n<p><a href=\"https://docs.aws.amazon.com/ko_kr/AmazonCloudFront/latest/DeveloperGuide/lambda-examples.html#lambda-examples-generated-response-examples\">함수 예제</a>를 참고하여 Viewer request에서 바로 응답을 생성하는 함수를 작성합니다. 이때, response body에는 <code>handler</code> 함수의 <code>event</code> 파라미터를 <code>JSON.stringify()</code>로 처리하여 넣습니다.</p>\n</li>\n<li>\n<p>웹사이트의 CloudFront에 람다 함수를 연결합니다. 웹사이트에 접속하면 실제 Viewer request 이벤트를 본문으로 얻을 수 있습니다.</p>\n</li>\n</ol>\n<p>위와 같은 과정을 거쳐 테스트 데이터를 얻고, 무사히 원하는 기능을 구현할 수 있었습니다.</p>\n<h2>결론</h2>\n<p>처음에는 CSR 환경에서 동적 OG 태그 적용이 불가능하다고 생각했으나, 인프라를 활용하여 문제를 해결할 수 있었습니다. 이 과정에서 프론트엔드만으로는 해결하기 어려운 문제도 배포 환경에서 적절한 설정으로 해결할 수 있다는 점을 확인했습니다.</p>\n<p>이 글이 같은 문제를 겪는 분들에게 실질적인 도움이 되기를 바랍니다.</p>","frontmatter":{"title":"CSR에서 동적 OG 적용하기","date":"2024-07-23","tags":["AWS","Troubleshooting"],"thumbnail":null},"timeToRead":3}},"pageContext":{"id":"be20c605-a8df-5893-a607-08168aae7b38"}},"staticQueryHashes":["1147043159"],"slicesMap":{}}